# Pending
1. Variable assignment
    1.1. Type checking
        1.1.1. Int literal can be assigned to a float variable, but not vice versa.                                                 âœ…
        1.1.2. String literal of length 1 can be assigned to a char variable. IMPLEMENT CHAR LITERAL AS STRING LITERAL OF LENGTH 1? âœ…
        1.1.3. Simple types are assign by value. Complex types are assign by reference. ????
    1.2 Constant can't be reassigned.   âœ…
2. Scope related
    2.1 Variable can't be declared twice in the same scope.     âœ…
    2.2 Search in parent scope if not found in current scope.   âœ…
3. Semantic visitor
    3.1 validate transfer stmt on guard stmt ðŸ•
4. Operators
    4.1 Null makes all result null      âœ…
5. Switch
    5.1. Implicit break on case stmt    âœ…
6. Funcs
    6.1. Check inner, outer, and positional args. âœ…
    6.2. Reference IVOR âœ…
7. Vectors
    7.1 empty [] implicit case âœ…
8. Structs
    8.1. Dcl visit ðŸ•
    8.2. Pointers of structs âœ…
    8.3. Reuse func grammar âœ…
    8.4. a[0][0].prop âœ…
    8.5. Auto Referece ðŸ•
    8.6. Mutual Reference ðŸ•
9. Lexical and Syntax errors

# Next Steps
1. if stmt              âœ…
2. switch stmt          âœ…
3. while stmt           âœ…
4. for stmt             âœ…
5. guard stmt           âœ…
6. callstack            âœ…
    6.1. break          âœ…  
    6.2. continue       âœ…
7. function
    7.1. builtins       âœ…
    7.2. declaration    âœ…
    7.3. call           âœ…
    7.4. return         âœ…
    ? pass by reference âœ…
8. Complex types
    8.1. vector         âœ…
        8.1.1. iterator âœ…
        8.1.2. builtins âœ…
        8.1.2. access   âœ…
    8.2. matrix âœ…
    8.3. struct âœ…


# Improvements

1. Eval items on call stack instead of removing them âœ…
2. validate it first on the semachecker visitor      

# Notes
stackable elements: switch, while, for, function




# Matrix Grammar Of Python
list:
    | '[' [star_named_expressions] ']' 


// Match one or more occurrences of e, separated by s. The generated parse tree does not include the separator. This is otherwise identical to (e (s e)*).
star_named_expressions: ','.star_named_expression+ [','] 

star_named_expression:
    | '*' bitwise_or 
    | named_expression

named_expression:
    | assignment_expression
    | expression !':=' ->list

--- java ---

ElementValueArrayInitializer:
    { [ElementValues] [,] }

ElementValues:
    ElementValue { , ElementValue }

